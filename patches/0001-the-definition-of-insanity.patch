From 2e69891b43f19932bf832f7306950ac3bafb33d4 Mon Sep 17 00:00:00 2001
From: RedFoxIV <38788538+RedFoxIV@users.noreply.github.com>
Date: Sun, 25 May 2025 02:18:34 +0300
Subject: [PATCH 1/3] the definition of insanity

---
 Content.Client/Entry/EntryPoint.cs            |   2 +
 .../ItemSlotRendererComponent.cs              |  42 +++++
 .../ItemSlotRendererSystem.cs                 | 177 ++++++++++++++++++
 Content.Server/Entry/IgnoredComponents.cs     |   1 +
 .../Entities/Structures/Power/chargers.yml    |  15 ++
 5 files changed, 237 insertions(+)
 create mode 100644 Content.Client/_White/ItemSlotRenderer/ItemSlotRendererComponent.cs
 create mode 100644 Content.Client/_White/ItemSlotRenderer/ItemSlotRendererSystem.cs

diff --git a/Content.Client/Entry/EntryPoint.cs b/Content.Client/Entry/EntryPoint.cs
index d8c9680c79..5d233ea914 100644
--- a/Content.Client/Entry/EntryPoint.cs
+++ b/Content.Client/Entry/EntryPoint.cs
@@ -39,6 +39,7 @@
 using Robust.Shared.Replays;
 using Robust.Shared.Timing;
 using Content.Client._White.Overlays;
+using Content.Client._White.ItemSlotRenderer;
 
 namespace Content.Client.Entry
 {
@@ -161,6 +162,7 @@ public override void PostInit()
             _overlayManager.AddOverlay(new FlashOverlay());
             _overlayManager.AddOverlay(new RadiationPulseOverlay());
             _overlayManager.AddOverlay(new GrainOverlay()); // WD EDIT
+            _overlayManager.AddOverlay(new SpriteToLayerBullshitOverlay()); // WD EDIT
             _chatManager.Initialize();
             _clientPreferencesManager.Initialize();
             _euiManager.Initialize();
diff --git a/Content.Client/_White/ItemSlotRenderer/ItemSlotRendererComponent.cs b/Content.Client/_White/ItemSlotRenderer/ItemSlotRendererComponent.cs
new file mode 100644
index 0000000000..33dcd7a8d3
--- /dev/null
+++ b/Content.Client/_White/ItemSlotRenderer/ItemSlotRendererComponent.cs
@@ -0,0 +1,42 @@
+using Robust.Client.GameObjects;
+using Robust.Client.Graphics;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Content.Client._White.ItemSlotRenderer;
+
+[RegisterComponent]
+public sealed partial class ItemSlotRendererComponent : Component
+{
+    // string layer mappings to slot ids
+    [DataField]
+    public Dictionary<string, string> PrototypeLayerMappings = new();
+
+    // [mapkey] = slotId
+    [ViewVariables(VVAccess.ReadWrite)]
+    public List<(object, string)> LayerMappings = new();
+
+    // [slotId] = entity uid
+    [ViewVariables(VVAccess.ReadOnly)]
+    public Dictionary<string, EntityUid?> CachedEntities = new();
+
+    // [slotId] = IRenderTexture
+    [ViewVariables(VVAccess.ReadOnly)]
+    public Dictionary<string, IRenderTexture> CachedRT = new();
+
+    [DataField]
+    public bool IgnoreMissing = false;
+
+    [DataField]
+    public Vector2i RenderTargetSize = new Vector2i(32, 32);
+}
+
+/*
+            if (reflection.TryParseEnumReference(keyString, out var @enum))
+                return @enum;
+
+            return keyString;
+*/
diff --git a/Content.Client/_White/ItemSlotRenderer/ItemSlotRendererSystem.cs b/Content.Client/_White/ItemSlotRenderer/ItemSlotRendererSystem.cs
new file mode 100644
index 0000000000..92fb701ded
--- /dev/null
+++ b/Content.Client/_White/ItemSlotRenderer/ItemSlotRendererSystem.cs
@@ -0,0 +1,177 @@
+using Content.Client.Hands;
+using Content.Shared._White.Hands.Components;
+using Content.Shared.Containers.ItemSlots;
+using Microsoft.CodeAnalysis.Elfie.Serialization;
+using Robust.Client.GameObjects;
+using Robust.Client.Graphics;
+using Robust.Client.Input;
+using Robust.Shared.Containers;
+using Robust.Shared.Enums;
+using Robust.Shared.Graphics;
+using Robust.Shared.Map;
+using Robust.Shared.Player;
+using Robust.Shared.Reflection;
+using Robust.Shared.Timing;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Numerics;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Content.Client._White.ItemSlotRenderer;
+
+public sealed class ItemSlotRendererSystem : EntitySystem
+{
+    [Dependency] private readonly IReflectionManager _reflection = default!;
+    [Dependency] private readonly ItemSlotsSystem _slot = default!;
+
+    private IGameTiming? _timing = null;
+    public override void Initialize()
+    {
+        SubscribeLocalEvent<ItemSlotRendererComponent, ComponentStartup>(OnStartup);
+        SubscribeLocalEvent<ItemSlotRendererComponent, ComponentRemove>(OnRemove);
+        SubscribeLocalEvent<ItemSlotRendererComponent, ContainerIsInsertingAttemptEvent>(OnInsertIntoContainer);
+        SubscribeLocalEvent<ItemSlotRendererComponent, ContainerIsRemovingAttemptEvent>(OnRemoveFromContainer);
+
+    }
+    private void OnInsertIntoContainer(EntityUid uid, ItemSlotRendererComponent comp, ContainerIsInsertingAttemptEvent args)
+    {
+        _timing ??= IoCManager.Resolve<IGameTiming>();
+        if (args.Container is not ContainerSlot || !_timing.IsFirstTimePredicted)
+            return;
+
+        comp.CachedEntities[args.Container.ID] = args.EntityUid;
+    }
+
+    private void OnRemoveFromContainer(EntityUid uid, ItemSlotRendererComponent comp, ContainerIsRemovingAttemptEvent args)
+    {
+        _timing ??= IoCManager.Resolve<IGameTiming>();
+        if (args.Container is not ContainerSlot || !_timing.IsFirstTimePredicted)
+            return;
+
+        comp.CachedEntities[args.Container.ID] = null;
+    }
+
+    private void OnRemove(EntityUid uid, ItemSlotRendererComponent comp, ComponentRemove args)
+    {
+        foreach (var (_, renderTexture) in comp.CachedRT)
+            renderTexture.Dispose();
+    }
+
+    private void OnStartup(EntityUid uid, ItemSlotRendererComponent comp, ComponentStartup args)
+    {
+        if(!TryComp<SpriteComponent>(uid, out var sprite))
+        {
+            Log.Error($"ItemSlotRendererCompontn requires SpriteComponent to work, but {ToPrettyString(uid)} did not have one. Removing ItemSlotRenderer.");
+            RemComp<ItemSlotRendererComponent>(uid);
+            return;
+        }
+
+        foreach (var kvp in comp.PrototypeLayerMappings)
+        {
+
+            (object mapKey, string slotId) = kvp;
+
+            if (_reflection.TryParseEnumReference(kvp.Key, out var e, false))
+                mapKey = e;
+
+            if (sprite.LayerMapTryGet(mapKey, out _) && !comp.IgnoreMissing)
+            {
+                Log.Warning($"ItemSlotRenderer: Tried to add a missing layer under the key {mapKey}. Skipping missing layer. If this is unwanted, set component's AddMissingLayers to true.");
+                continue;
+            }
+
+            if(_slot.TryGetSlot(uid, slotId, out var slot))
+                comp.CachedEntities[slotId] = slot.Item;
+
+            comp.LayerMappings.Add((mapKey, slotId));
+
+            comp.CachedRT.Add(slotId, _clyde.CreateRenderTarget(comp.RenderTargetSize, new RenderTargetFormatParameters(RenderTargetColorFormat.Rgba8Srgb), new TextureSampleParameters { Filter = false }, $"{slotId}-itemrender-rendertarget"));
+        }
+    }
+
+    [Dependency] private readonly IClyde _clyde = default!;
+
+    //public override void FrameUpdate(float frameTime)
+    //{
+    //    var query = EntityQueryEnumerator<ItemSlotRendererComponent, SpriteComponent>();
+    //    while(query.MoveNext(out var uid, out var comp, out var sprite))
+    //    {
+    //        for(int i = 0; i < comp.LayerMappings.Count; i++)
+    //        {
+    //            var (key, slotId) = comp.LayerMappings[i];
+    //            if (comp.CachedEntities[slotId] is not EntityUid item ||
+    //                !TryComp<SpriteComponent>(item, out var itemSprite))
+    //                continue;
+    //
+    //        }
+    //    }
+    //}
+}
+
+
+
+public sealed class SpriteToLayerBullshitOverlay : Overlay
+{
+    [Dependency] private readonly IInputManager _input = default!;
+    [Dependency] private readonly IClyde _clyde = default!;
+    [Dependency] private readonly IEyeManager _eye = default!;
+    [Dependency] private readonly EntityManager _entMan = default!;
+
+
+    public override OverlaySpace Space => OverlaySpace.ScreenSpaceBelowWorld;
+    //private readonly Font _font;
+
+    public SpriteToLayerBullshitOverlay()
+    {
+        IoCManager.InjectDependencies(this);
+        //ZIndex = int.MinValue;
+    }
+
+    protected override void Draw(in OverlayDrawArgs args)
+    {
+        var handle = args.ScreenHandle;
+        var query = _entMan.EntityQueryEnumerator<ItemSlotRendererComponent, SpriteComponent>();
+        while (query.MoveNext(out var uid, out var comp, out var sprite))
+        {
+            for (int i = 0; i < comp.LayerMappings.Count; i++)
+            {
+                var (key, slotId) = comp.LayerMappings[i];
+                if (!comp.CachedRT.TryGetValue(slotId, out var renderTarget) ||
+                    !comp.CachedEntities.TryGetValue(slotId, out var _item) ||
+                    _item is not EntityUid item ||
+                    !_entMan.TryGetComponent<SpriteComponent>(item, out var itemSprite))
+                {
+                    sprite.LayerSetTexture(sprite.LayerMapGet(key), Texture.Transparent);
+                    continue;
+                }
+
+                handle.RenderInRenderTarget(renderTarget, () =>
+                {
+                    //sprite.Render(handle, 0, 0, null, _renderBackbuffer.Size / 2);
+                    handle.DrawEntity(item, renderTarget.Size / 2, Vector2.One, 0);
+                }, Color.Transparent);
+
+                sprite.LayerSetTexture(sprite.LayerMapGet(key), renderTarget.Texture);
+            }
+        }
+
+        /*
+        var mouseScreenPos = _input.MouseScreenPosition.Position;
+
+        var mouseMapPos = _eye.ScreenToMap(mouseScreenPos);
+        // Why do i have to do so much to simply convert Vector2 from screenspace to worldspace and back?
+        var finalMapPos = _hands.GetFinalDropCoordinates(player, _transform.GetMapCoordinates(player), mouseMapPos);
+        var finalScreenPos = _eye.MapToScreen(new MapCoordinates(finalMapPos, mouseMapPos.MapId)).Position;
+
+        var adjustedAngle = dropcomp.Angle;
+        handle.RenderInRenderTarget(_renderBackbuffer, () =>
+        {
+            handle.DrawEntity(held, _renderBackbuffer.Size / 2, new Vector2(2), adjustedAngle);
+        }, Color.Transparent);
+
+        handle.DrawTexture(_renderBackbuffer.Texture, finalScreenPos - _renderBackbuffer.Size / 2, Color.GreenYellow.WithAlpha(0.75f));
+        */
+    }
+}
diff --git a/Content.Server/Entry/IgnoredComponents.cs b/Content.Server/Entry/IgnoredComponents.cs
index b574246b06..41a4a381df 100644
--- a/Content.Server/Entry/IgnoredComponents.cs
+++ b/Content.Server/Entry/IgnoredComponents.cs
@@ -22,6 +22,7 @@ public static class IgnoredComponents
             "OptionsVisualizer",
             "ToggleableLightWieldable", // Goobstation
             "PixelSnapEye", // WWDP EDIT
+            "ItemSlotRenderer", // WWDP EDIT
         };
     }
 }
diff --git a/Resources/Prototypes/Entities/Structures/Power/chargers.yml b/Resources/Prototypes/Entities/Structures/Power/chargers.yml
index 3ffe6d0ac4..40d7974183 100644
--- a/Resources/Prototypes/Entities/Structures/Power/chargers.yml
+++ b/Resources/Prototypes/Entities/Structures/Power/chargers.yml
@@ -153,6 +153,17 @@
   components:
   - type: Sprite
     sprite: Structures/Power/recharger.rsi
+    layers:
+    - map: ["enum.PowerChargerVisualLayers.Base"]
+      state: "empty"
+    - map: ["enum.PowerChargerVisualLayers.Light"]
+      state: "light-off"
+      shader: "unshaded"
+    - map: [ "bullshit" ] 
+      shader: "FlickerHologram"
+      color: "#ffffffaa"
+      offset: 0,0.45
+      scale: 0.5,0.5
   - type: Machine
     board: WeaponCapacitorRechargerCircuitboard
   # no powercellslot since stun baton etc arent powercells
@@ -165,6 +176,10 @@
           - HitscanBatteryAmmoProvider
           - ProjectileBatteryAmmoProvider
           - Stunbaton
+  - type: ItemSlotRenderer
+    ignoreMissing: true
+    prototypeLayerMappings:
+      bullshit: charger_slot
 
 - type: entity
   parent: BaseItemRecharger
-- 
2.49.0.windows.1

